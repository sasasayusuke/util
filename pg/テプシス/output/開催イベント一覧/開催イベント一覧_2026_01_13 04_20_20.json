{
  "HeaderInfo": {
    "AssemblyVersion": "1.4.1.1",
    "BaseSiteId": 253771,
    "Server": "http://192.168.10.67",
    "CreatorName": "Administrator",
    "PackageTime": "2026-01-12T19:20:19.8907664+00:00",
    "Convertors": [
      {
        "SiteId": 253771,
        "SiteTitle": "開催イベント一覧",
        "ReferenceType": "Results",
        "IncludeData": false
      }
    ],
    "IncludeSitePermission": true,
    "IncludeRecordPermission": true,
    "IncludeColumnPermission": true,
    "IncludeNotifications": true,
    "IncludeReminders": true
  },
  "Sites": [
    {
      "TenantId": 1,
      "SiteId": 253771,
      "Title": "開催イベント一覧",
      "SiteName": "",
      "SiteGroupName": "",
      "Body": "",
      "GridGuide": "",
      "EditorGuide": "",
      "CalendarGuide": "",
      "CrosstabGuide": "",
      "GanttGuide": "",
      "BurnDownGuide": "",
      "TimeSeriesGuide": "",
      "AnalyGuide": "",
      "KambanGuide": "",
      "ImageLibGuide": "",
      "ReferenceType": "Results",
      "ParentId": 253088,
      "InheritPermission": 253088,
      "SiteSettings": {
        "Version": 1.017,
        "ReferenceType": "Results",
        "Styles": [
          {
            "Title": "【表示制御】開催イベント一覧画面スタイル",
            "Index": true,
            "Body": "@charset \"UTF-8\";\n/* ===================\n    外部呼出し\n==================*/\n/* ===================\n    色定義\n==================*/\n/* ===================\n    縦スペース定義\n==================*/\n/* ===================\n    横スペース定義\n==================*/\n/* ===================\n    テキストサイズ定義\n==================*/\n.sdt-upcomingEvents {\n  position: absolute;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  overflow: auto;\n  background-color: #F2F2F2;\n  z-index: 705;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-wrap {\n  position: relative;\n  display: block;\n  width: 100%;\n  height: 100%;\n  padding: 20px;\n  background-color: #F2F2F2;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-title {\n  margin: 0;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-title__text {\n  font-weight: bold;\n  font-size: 1.2em;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form__area {\n  position: relative;\n  width: 100%;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form__area {\n  display: flex;\n  align-items: center;\n  margin-top: 20px;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form__area {\n    margin-top: 15px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form__area {\n    flex-wrap: wrap;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-title {\n  width: 50px;\n  margin: 0;\n  padding: 0;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-title {\n    width: 100%;\n    margin-bottom: 9px;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data {\n  position: relative;\n  display: flex;\n  height: 30px;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data {\n    width: 45%;\n    margin-bottom: 15px;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data__tilde {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding-left: 12px;\n  padding-right: 12px;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data__tilde {\n    padding-left: 9px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data__tilde {\n    padding-right: 9px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-data__tilde {\n    width: 10%;\n    margin-bottom: 15px;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-form-label {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input {\n  width: 100%;\n  height: 100%;\n  padding: 0;\n  padding-left: 12px;\n  padding-right: 12px;\n  border-radius: 5px;\n  border: none;\n  box-shadow: 0 0 0 1px #78818F inset;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  font-size: 16px;\n  background-color: #fff;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input {\n    padding-left: 9px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input {\n    padding-right: 9px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input {\n    font-size: 14px;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input::-moz-placeholder {\n  color: #C4C9D0;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input::placeholder {\n  color: #C4C9D0;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input:focus {\n  outline: 0;\n  box-shadow: 0 0 0 2px #2F80ED inset;\n  color: #3B3B3B;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input:disabled {\n  color: #C4C9D0;\n  box-shadow: 0 0 0 2px #C4C9D0 inset;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input:-moz-read-only {\n  border: none;\n  outline: none;\n  box-shadow: none;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input:read-only {\n  border: none;\n  outline: none;\n  box-shadow: none;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-input--error {\n  box-shadow: 0 0 0 1px #E80000 inset;\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 50px;\n  height: 30px;\n  border-radius: 5px;\n  margin-left: 20px;\n  background-color: #2F80ED;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-button {\n    margin-left: 15px;\n  }\n}\n.sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-button__text {\n  color: #fff;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-upcomingEvents-form .sdt-button {\n    width: 100%;\n    margin: 0 80px;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap {\n  width: 100%;\n  overflow: auto;\n  margin-top: 21px;\n  border: solid 1px #3B3B3B;\n  border-top: none;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap {\n    margin-top: 0;\n    border: none;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-column {\n  display: flex;\n  width: auto;\n  background-color: #fff;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-column {\n    flex-wrap: wrap;\n    margin-top: 21px;\n    padding: 12px;\n    border: solid 1px #3B3B3B;\n  }\n}\n@media screen and (max-width: 760px) and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-column {\n    padding: 9px;\n  }\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-column + .sdt-table-variable-column {\n    margin-top: 21px;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  flex-direction: column;\n  border-top: solid 1px #3B3B3B;\n  background-color: #fff;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell {\n    flex-direction: row;\n    border: none;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Date] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Date] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Category] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Category] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Area] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Area] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=AreaDetails] {\n  min-width: 150px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=AreaDetails] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EventName] {\n  min-width: 150px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EventName] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=BusinessStore] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=BusinessStore] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EventPeriod] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EventPeriod] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=StartTime] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=StartTime] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EndTime] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=EndTime] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=PersonCharge] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=PersonCharge] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Button] {\n  min-width: 120px;\n  width: 10%;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell[data-style=Button] {\n    min-width: auto;\n    width: 100%;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-head, .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-body {\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: auto;\n  margin-top: -1px;\n  padding: 5px 10px;\n}\n@media screen and (max-width: 760px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-head, .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-body {\n    justify-content: flex-start;\n    padding: 5px 5px;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-head {\n  font-weight: bold;\n}\n@media screen and (min-width: 761px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-head {\n    min-height: 50px;\n    border-bottom: solid 1px #3B3B3B;\n  }\n}\n.sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-cell-body {\n  height: 100%;\n}\n@media screen and (min-width: 761px) {\n  .sdt-upcomingEvents .sdt-table-variable .sdt-table-variable-wrap .sdt-table-variable-column:not(:first-child) .sdt-table-variable-cell-head {\n    display: none;\n  }\n}",
            "Id": 1
          }
        ],
        "Scripts": [
          {
            "Title": "【設定】サイト",
            "All": true,
            "Body": "const eventDaySiteId = \"253140\";　//イベント当日\nconst periodSiteId = \"253154\"; 　//開始～終了期間",
            "Id": 6
          },
          {
            "Title": "【表示制御】開催イベント一覧初期表示設定",
            "Index": true,
            "Body": "(function ($) {\n  'use strict';\n\n  /************************************************************************\n   * 画面読み込み時に一度だけ実行するレイアウト処理\n   *\n   * 目的：\n   *  - ヘッダー（#Header）の高さを取得して、その高さ分だけ\n   *    #sdt-upcomingEvents の top をずらします（重なり防止）。\n   *  - さらに #sdt-upcomingEvents の高さを CSS の calc() を使って\n   *    calc(100% - {headerHeight}px) に設定します。これにより、\n   *    ビューポート全体の高さからヘッダー分を差し引いた高さにできます。\n   *\n   * 注意：\n   *  - この処理は「読み込み時に一度だけ実行」されます。画面サイズ変更で追従\n   *    させたい場合は下の「リサイズ追従（任意）」のコメントを参考に有効化してください。\n   *  - #sdt-upcomingEvents に top を効かせるには、その要素に適切な position（relative/absolute/fixed/sticky）\n   *    が CSS で設定されている必要があります。もし反映されない場合は CSS 側を確認してください。\n   ************************************************************************/\n\n  /**\n   * getHeaderHeight\n   * - #Header 要素の「見た目の高さ」をピクセル単位で返します。\n   * - 見た目の高さとは、実際に画面に描画された高さ（border・padding を含むサイズ）です。\n   * - 要素が見つからなければ 0 を返します（呼び出し側で扱いやすくするため）。\n   *\n   * 基本の考え方（初心者向け）：\n   *  - jQuery の .height() は「コンテンツ高さ」を返しますが、\n   *    getBoundingClientRect().height は表示上の高さ（細かい描画情報）を返すので、\n   *    見た目を合わせたい時はこちらを使うことが多いです。\n   *\n   * @returns {number} headerHeightPx - 整数ピクセル（例: 64）\n   */\n  function getHeaderHeight() {\n    // jQuery で要素を取得\n    var $header = $('#Header');\n\n    // 要素が無ければ 0 を返す（安全なフォールバック）\n    if ($header.length === 0) {\n      return 0;\n    }\n\n    // ネイティブ DOM の getBoundingClientRect() で「見た目の高さ」を取得\n    var rect = $header[0].getBoundingClientRect();\n\n    // 小数点が乗ることがあるため四捨五入して整数にする（CSS に入れやすくするため）\n    // 例: 63.4 -> 63\n    var h = Math.round(rect.height || 0);\n\n    // 負の高さなど不正値が来ないように最低限のガード\n    return (h > 0) ? h : 0;\n  }\n\n  /**\n   * buildCalcHeightCss\n   * - ヘッダーのピクセル値を受け取り、CSS の calc() 文字列を返します。\n   * - 例: px=50 -> \"calc(100% - 50px)\"\n   *\n   * @param {number} px - ヘッダー高さ（ピクセル）\n   * @returns {string} CSS の値（例: \"calc(100% - 50px)\"）\n   */\n  function buildCalcHeightCss(px) {\n    // 安全のため数値に変換してから文字列を生成\n    var n = (typeof px === 'number' && !isNaN(px)) ? px : 0;\n    return 'calc(100% - ' + String(n) + 'px)';\n  }\n\n  /**\n   * applyUpcomingEventsLayout\n   * - 実際に DOM に対して style を当てる関数（書き込みのみ）\n   * - headerHeightPx が数値で与えられたら top と height を設定します。\n   * - 要素が無ければ何もしません（無害で安全）。\n   *\n   * @param {number} headerHeightPx - ヘッダーの高さ（ピクセル）\n   */\n  function applyUpcomingEventsLayout(headerHeightPx) {\n    // 対象要素を取得\n    var $target = $('#fn-upcomingEvents');\n\n    // 要素が無ければ早期リターン（処理を止めない）\n    if ($target.length === 0) {\n      return;\n    }\n\n    // top をピクセルで設定（例: \"64px\"）\n    $target.css('top', String(headerHeightPx) + 'px');\n\n    // height を calc(100% - {headerHeight}px) に設定\n    $target.css('height', buildCalcHeightCss(headerHeightPx));\n  }\n\n  /**\n   * initUpcomingEventsLayout\n   * - 画面読み込み時に呼ばれるオーケストレーション関数\n   * - 役割: ヘッダー高さを取得して、対象要素にレイアウトを適用する（1回だけ）\n   */\n  function initUpcomingEventsLayout() {\n    // ヘッダーの高さを取得（例: 64）\n    var headerH = getHeaderHeight();\n\n    // 取得した高さを使って対象要素にスタイルを適用\n    applyUpcomingEventsLayout(headerH);\n  }\n\n  // DOMContentLoaded のタイミングで一度だけ実行する\n  document.addEventListener('DOMContentLoaded', function () {\n    try {\n      initUpcomingEventsLayout();\n    } catch (e) {\n      // エラーが出たときは開発用に console に出す（運用では消してもよい）\n      // window.force を true にすると詳細ログが出ます（デバッグ用）\n      window.force && console.error('initUpcomingEventsLayout error', e);\n    }\n  });\n\n  /* --------------------------------------------------------------------\n   * リサイズ時に高さを再計算して追従させたい場合（任意）\n   *\n   * - 画面サイズが変わるとヘッダーの高さが変化する UI がある場合は、\n   *   下のコードを有効化してください。\n   * - 最小限の実装を心がけるためデフォルトでは無効にしています。\n   *\n   * // window.addEventListener('resize', function () {\n   * //   try {\n   * //     initUpcomingEventsLayout();\n   * //   } catch (e) {\n   * //     window.force && console.error('resize initUpcomingEventsLayout error', e);\n   * //   }\n   * // });\n   * ------------------------------------------------------------------ */\n\n  /* --------------------------------------------------------------------\n   * 補足（初心者向け Q&A）\n   *\n   * Q: なぜ top を設定するだけで表示がずれるの？\n   * A: top は要素が position: absolute/fixed/sticky/relative の時に意味を持ちます。\n   *    もし #sdt-upcomingEvents に position が無い（static）場合、top は効きません。\n   *    その場合は CSS に position: relative; などを設定してください。\n   *\n   * Q: calc(100% - 50px) は何を意味するの？\n   * A: 親要素の高さやビューポート高さを基準に 100% から 50px を引いた高さを意味します。\n   *    ここでは「画面全体の高さ - ヘッダーの高さ」を意図しています。\n   *\n   * Q: この処理を手動で再実行する方法は？\n   * A: このファイルは外部公開しない方針なので直接呼べる関数は置いていません。\n   *    もし手動で呼びたい場合は initUpcomingEventsLayout を global に公開してください。\n   * ------------------------------------------------------------------ */\n\n})(jQuery);\n",
            "Id": 1
          },
          {
            "Title": "【画面処理】表の作成",
            "Index": true,
            "Disabled": true,
            "Body": "(function ($) {\n  'use strict';\n\n  /*************************************************************************\n   * upcoming events — 初心者向けに丁寧にコメントした実装\n   *\n   * 全体の流れ（上位関数: upcomingEventsFormAction）\n   * 1) 入力（開始日・終了日）を取得\n   * 2) 取得した日付を alert で表示（今回の代替動作）\n   * 3) API の代わりにダミーデータを取得（fetchEventsDummy）\n   * 4) 各イベントの開催期間 (EventPeriod) を解析し、\n   *    期間内の日ごとに行を「穴埋め」する（expandEventsByPeriod）\n   * 5) 生成した行を HTML として描画する（renderEvents）\n   *\n   * 注意:\n   * - 外部公開は upcomingEventsFormAction のみ（onclick 用）\n   * - 他の関数は IIFE 内に閉じます（読みやすさ優先）\n   *************************************************************************/\n\n  /**\n   * getInputDates\n   * - 画面にある #fn-startDatet と #fn-endDate の input 要素から値を取得します。\n   * - 要素が無ければ空文字を返します（呼び出し側で扱いやすい形に統一するため）。\n   *\n   * 戻り値の構造:\n   *   { start: 'YYYY-MM-DD など', end: 'YYYY-MM-DD など' }\n   */\n  function getInputDates() {\n    // jQuery で要素を取得\n    var $start = $('#fn-startDate');\n    var $end = $('#fn-endDate');\n\n    // val() が undefined なら '' に統一して返す\n    return {\n      start: ($start.length ? String($start.val() || '') : ''),\n      end: ($end.length ? String($end.val() || '') : '')\n    };\n  }\n\n  /**\n   * showDatesAlert\n   * - 取得した日付を画面に alert で表示します（API 実行の代替挙動）。\n   * - ここはデバッグ／動作確認用なので、実運用では API 呼び出しに置き換えます。\n   */\n  function showDatesAlert(dates) {\n    // 短く見やすいメッセージで表示\n    alert('開始: ' + dates.start + '\\n終了: ' + dates.end);\n  }\n\n  /**\n   * fetchEventsDummy\n   * - 本来はサーバー API を叩いてイベントを取得する場所。\n   * - 今回はダミーの配列を返す（非同期のふりをするため Deferred を返す）。\n   *\n   * 引数:\n   *   dates - 将来 API に渡す可能性のある日付オブジェクト（今回は使わない）\n   *\n   * 戻り値:\n   *   jQuery Deferred.promise() を返す（resolve されると配列が返る）\n   */\n  function fetchEventsDummy(dates) {\n    var dfd = $.Deferred();\n\n    // ダミーデータ（配列の各要素はイベントを表すオブジェクト）\n    var dummy = [\n      {\n        Date: '2026-03-01',\n        Category: 'ワークショップ',\n        Area: '東京・渋谷センター',\n        EventName: 'フロントエンド勉強会',\n        EventUrl: '#',\n        BusinessStore: 'Tech事業部',\n        EventPeriod: '2026/03/01 - 2026/03/03', // 期間形式（開始 - 終了）\n        StartTime: '10:00',\n        EndTime: '17:00',\n        PersonCharge: '山田 太郎'\n      },\n      {\n        Date: '2026-03-05',\n        Category: 'セミナー',\n        Area: '大阪・梅田会場',\n        EventName: 'JS 深掘りセミナー',\n        EventUrl: '#',\n        BusinessStore: '研修部',\n        EventPeriod: '2026/03/05 - 2026/03/05',\n        StartTime: '09:30',\n        EndTime: '16:30',\n        PersonCharge: '佐藤 花子'\n      },\n      {\n        Date: '2026-03-10',\n        Category: '展示会',\n        Area: '名古屋会場',\n        EventName: '製品展示会',\n        EventUrl: '#',\n        BusinessStore: '営業部',\n        EventPeriod: '2026/03/10 - 2026/03/12',\n        StartTime: '11:00',\n        EndTime: '18:00',\n        PersonCharge: '田中 次郎'\n      }\n    ];\n\n    // 即時に解決（将来は $.ajax() 等に差し替える）\n    setTimeout(function () { dfd.resolve(dummy); }, 0);\n    return dfd.promise();\n  }\n\n  /******************************************************************\n   * ここから「期間展開（穴埋め）」に関する補助関数群（初心者向けに丁寧に）\n   ******************************************************************/\n\n  /**\n   * parsePeriod\n   * - EventPeriod の文字列（例: \"2026/03/01 - 2026/03/03\"）から\n   *   開始日と終了日を Date オブジェクトにして返す関数\n   *\n   * - サポートする形式: yyyy/mm/dd または yyyy-mm-dd が本文中に 1 個以上あるもの\n   * - 解析に失敗したら null を返す（呼び出し側でフォールバック処理を行う）\n   *\n   * 戻り値の例:\n   *   { start: DateObject, end: DateObject } または null\n   */\n  function parsePeriod(periodStr) {\n    if (!periodStr || typeof periodStr !== 'string') return null;\n\n    // 正規表現で yyyy/mm/dd または yyyy-mm-dd をすべて探す\n    var re = /(\\d{4})[\\/\\-](\\d{1,2})[\\/\\-](\\d{1,2})/g;\n    var matches = [];\n    var m;\n    while ((m = re.exec(periodStr)) !== null) {\n      matches.push({ y: parseInt(m[1], 10), mo: parseInt(m[2], 10), d: parseInt(m[3], 10) });\n    }\n\n    // 日付が見つからなければ null\n    if (matches.length === 0) return null;\n\n    // 見つかった最初の 1 個を開始日、2 個目を終了日（2 個無ければ開始と同じ日を終了とする）\n    var s = matches[0];\n    var e = matches.length > 1 ? matches[1] : matches[0];\n\n    // Date コンストラクタに渡す（注意: 月は 0 起点なので -1 する）\n    var startDate = new Date(s.y, s.mo - 1, s.d);\n    var endDate = new Date(e.y, e.mo - 1, e.d);\n\n    // 日付の妥当性チェック\n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return null;\n\n    // start が end より後なら入れ替える（安全措置）\n    if (startDate.getTime() > endDate.getTime()) {\n      var tmp = startDate;\n      startDate = endDate;\n      endDate = tmp;\n    }\n\n    return { start: startDate, end: endDate };\n  }\n\n  /**\n   * getDatesInRange\n   * - 開始日から終了日まで（両端 inclusive）の Date オブジェクト配列を返す。\n   * - 例: start=2026-03-01, end=2026-03-03 => [2026-03-01, 2026-03-02, 2026-03-03]\n   *\n   * ※ Date はコピーして返します（元の Date を壊さないように）\n   */\n  function getDatesInRange(start, end) {\n    var dates = [];\n    if (!(start instanceof Date) || !(end instanceof Date)) return dates;\n\n    // 日付は時間情報の差が入ると比較が面倒になるため、年月日だけで新しい Date を作る（時間は 00:00）\n    var cur = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n    var last = new Date(end.getFullYear(), end.getMonth(), end.getDate());\n\n    while (cur.getTime() <= last.getTime()) {\n      // 配列にはコピーを入れる（同じオブジェクト参照を避ける）\n      dates.push(new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()));\n      // 1 日進める\n      cur.setDate(cur.getDate() + 1);\n    }\n\n    return dates;\n  }\n\n  /**\n   * formatToDisplayDate\n   * - Date オブジェクトを「3月1日」のような表示用文字列に変換する小さなユーティリティ\n   * - 表示を見やすくするために使います\n   */\n  function formatToDisplayDate(dateObj) {\n    if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) return '';\n    var month = dateObj.getMonth() + 1; // 月は 0 起点なので +1\n    var day = dateObj.getDate();\n    return month + '月' + day + '日';\n  }\n\n  /**\n   * expandEventsByPeriod\n   * - 元の eventsArray（各要素がイベントオブジェクト）を受け取り、\n   *   EventPeriod を解析して期間分（1日ごと）に複製・展開した新しい配列を返す関数\n   *\n   * - 例:\n   *   元: [{ EventPeriod: \"2026/03/01 - 2026/03/03\", ... }]\n   *   結果: [{ Date: \"3月1日\", ... }, { Date: \"3月2日\", ... }, { Date: \"3月3日\", ... }]\n   *\n   * - 解析に失敗した要素は「元の要素を1行分だけ使う」ようにしています（最小限のフォールバック）\n   */\n  function expandEventsByPeriod(eventsArray) {\n    if (!Array.isArray(eventsArray)) return [];\n\n    var out = [];\n\n    // 1つずつ処理\n    eventsArray.forEach(function (item) {\n      // EventPeriod を解析して start / end を得る（失敗すれば null）\n      var period = parsePeriod(item.EventPeriod);\n\n      if (period) {\n        // 期間が解析できたら、その期間の日ごとに行を作る\n        var days = getDatesInRange(period.start, period.end);\n\n        days.forEach(function (d) {\n          // shallow copy: 必要最小限の複製（元のオブジェクトを壊さないため）\n          var copy = Object.assign({}, item);\n\n          // 表示用の日付として \"3月1日\" 形式を入れる\n          copy.Date = formatToDisplayDate(d);\n\n          // ここで StartTime / EndTime を日別に調整したい場合は追加可能（今回は元を使う）\n          out.push(copy);\n        });\n      } else {\n        // 解析できなければ、元の要素をそのまま 1 行として使う\n        var fallback = Object.assign({}, item);\n\n        // 可能なら Date を見やすく整形しておく（元の Date が yyyy/mm/dd 形式なら変換）\n        if (fallback.Date) {\n          var m = String(fallback.Date).match(/(\\d{4})[\\/\\-](\\d{1,2})[\\/\\-](\\d{1,2})/);\n          if (m) {\n            var fd = new Date(parseInt(m[1], 10), parseInt(m[2], 10) - 1, parseInt(m[3], 10));\n            if (!isNaN(fd.getTime())) {\n              fallback.Date = formatToDisplayDate(fd);\n            }\n          }\n        }\n\n        out.push(fallback);\n      }\n    });\n\n    return out;\n  }\n\n  /******************************************************************\n   * HTML 作成（各セル／各列を作る関数群）\n   * - buildCellElement: 1 セル（ヘッダ + 本文）を作る\n   * - buildColumnElement: 1 レコード（複数セル）を作る\n   *\n   * これらは DOM を直接作る補助で、読みやすさを優先して分割しています。\n   ******************************************************************/\n\n  /**\n   * buildCellElement\n   * - data-style 属性、ヘッダ表示テキスト、本文を受け取りセルの DOM を返す\n   * - bodyContent が文字列ならテキストとして追加、jQuery 要素ならそのまま追加\n   */\n  function buildCellElement(dataStyle, headText, bodyContent) {\n    // 親のセル要素 <div class=\"sdt-table-variable-cell\" data-style=\"...\">\n    var $cell = $('<div>').addClass('sdt-table-variable-cell').attr('data-style', dataStyle);\n\n    // ヘッダ部\n    var $head = $('<div>').addClass('sdt-table-variable-cell-head');\n    $head.append($('<p>').addClass('sdt-table-variable-cell-head__text').text(headText));\n    $cell.append($head);\n\n    // 本文部\n    var $body = $('<div>').addClass('sdt-table-variable-cell-body');\n    var $bodyTextWrap = $('<p>').addClass('sdt-table-variable-cell-body__text');\n\n    if (bodyContent && bodyContent instanceof jQuery) {\n      // もしリンクなど jQuery 要素が渡されたらそれをそのまま入れる\n      $bodyTextWrap.append(bodyContent);\n    } else {\n      // 文字列ならエスケープ（text() を使うことで HTML 挿入を防ぐ）\n      $bodyTextWrap.text(String(bodyContent || ''));\n    }\n\n    $body.append($bodyTextWrap);\n    $cell.append($body);\n\n    return $cell;\n  }\n\n  /**\n   * buildColumnElement\n   * - 1 レコード（イベント）から「column」DOM を作ります。\n   * - buildCellElement を使ってセルを順に追加するだけなので読みやすく少ない処理量にしています。\n   *\n   * 入力 item の主な期待プロパティ:\n   *   Date, Category, Area, EventName, EventUrl, BusinessStore, EventPeriod, StartTime, EndTime, PersonCharge\n   */\n  function buildColumnElement(item) {\n    var $col = $('<div>').addClass('sdt-table-variable-column');\n\n    // 日付セル\n    $col.append(buildCellElement('Date', '日付', item.Date || ''));\n\n    // カテゴリ\n    $col.append(buildCellElement('Category', 'カテゴリー', item.Category || ''));\n\n    // エリア詳細\n    $col.append(buildCellElement('Area', '開催エリア詳細', item.Area || ''));\n\n    // イベント名（リンク）\n    var $link = $('<a>').addClass('sdt-link').attr('href', item.EventUrl || '#').text(item.EventName || '');\n    $col.append(buildCellElement('EventName', 'イベント先名称', $link));\n\n    // 事業名・店舗名\n    $col.append(buildCellElement('BusinessStore', '事業名・店舗名', item.BusinessStore || ''));\n\n    // 開催期間（元の文字列を表示）\n    $col.append(buildCellElement('EventPeriod', '開催期間', item.EventPeriod || ''));\n\n    // 勤務開始時間 / 勤務終了時間\n    $col.append(buildCellElement('StartTime', '勤務開始時間', item.StartTime || ''));\n    $col.append(buildCellElement('EndTime', '勤務終了時間', item.EndTime || ''));\n\n    // 担当者\n    $col.append(buildCellElement('PersonCharge', '担当者', item.PersonCharge || ''));\n\n    // 入力ボタン（リンク） - ページ遷移させたくないので preventDefault している\n    var $inputA = $('<a>')\n      .addClass('sdt-inputButton')\n      .attr('href', '#')\n      .text('入力')\n      .on('click', function (e) {\n        e.preventDefault();\n        // ここで必要なら別の処理（モーダル表示等）を呼び出す\n      });\n\n    $col.append(buildCellElement('Button', '入力ボタン', $inputA));\n\n    return $col;\n  }\n\n  /******************************************************************\n   * 描画処理\n   * - renderEvents: 生成した配列を #sdt-upcomingEvents-table の中に挿入する\n   ******************************************************************/\n\n  /**\n   * renderEvents\n   * - eventsArray が配列かをチェックし、挿入先要素がある場合は中身をクリアして\n   *   配列の順番どおりに column 要素を追加します。\n   *\n   * 挿入先セレクタ:\n   *   #sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap\n   */\n  function renderEvents(eventsArray) {\n    if (!Array.isArray(eventsArray)) return;\n\n    var $wrap = $('#sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap');\n    if ($wrap.length === 0) {\n      // 挿入先がない場合は何もしない（処理を止めない）\n      return;\n    }\n\n    // 既存の内容を消す（毎回全置換する仕様）\n    $wrap.empty();\n\n    // 1 件ずつカラムを作って追加する（配列の順序を保つ）\n    eventsArray.forEach(function (item) {\n      var $col = buildColumnElement(item);\n      $wrap.append($col);\n    });\n  }\n\n  /******************************************************************\n   * オーケストレーション関数（ボタン onclick で呼ばれる）\n   *\n   * - 入力取得 → alert 表示 → ダミーデータ取得 → 期間展開 → 描画\n   * - シンプルで追いやすい順序にしています（初心者でもたどりやすい）\n   ******************************************************************/\n  function upcomingEventsFormAction(evt) {\n    // もし onclick がイベントを渡してくる場合はページ遷移を防ぐ\n    if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();\n\n    // 1) 入力値を取得\n    var dates = getInputDates();\n\n    // 2) 入力値をアラートで確認（ここが API 呼び出しの代替）\n    showDatesAlert(dates);\n\n    // 3) ダミーでデータを取得（将来は API に差し替え）\n    fetchEventsDummy(dates).done(function (eventsArray) {\n      try {\n        // 4) EventPeriod を解析して日毎に展開（穴埋め）\n        var expanded = expandEventsByPeriod(eventsArray);\n\n        // 5) 描画\n        renderEvents(expanded);\n      } catch (e) {\n        // 本番では適切なエラーハンドリングを行うが、ここでは最小限に留める\n        window.force && console.error('upcoming events error', e);\n      }\n    }).fail(function (err) {\n      // 取得失敗時（ダミーでは起きないが、将来の API 用にログを残す）\n      window.force && console.error('fetchEventsDummy failed', err);\n    });\n  }\n\n  // グローバルに公開（onclick 属性で呼び出せるように）\n  window.upcomingEventsFormAction = upcomingEventsFormAction;\n\n  /*************************************************************************\n   * 補足（使用方法）\n   * - ボタンに: <button onclick=\"upcomingEventsFormAction(event)\">実行</button>\n   * - フォームに: <input id=\"fn-startDatet\"> と <input id=\"fn-endDate\"> を用意\n   * - 描画先は: #sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap\n   *\n   * 変更・拡張ポイント（将来の実装メモ）\n   * - fetchEventsDummy を $.ajax に差し替えて実データを取得する\n   * - 日付形式のバリエーションが増えたら parsePeriod を拡張する\n   *************************************************************************/\n\n})(jQuery);\n",
            "Id": 2
          },
          {
            "Title": "【共通関数】拡張SQL",
            "All": true,
            "Body": "// =====================\n// 共通設定\n// =====================\nconst ENDPOINT = \"http://192.168.10.67/api/extended/sql\";\nconst API_VERSION = 1.1;\nconst API_KEY = \"f326ba9d430b60fb2d5dc39ab17ef7464d88791c1729781b9b5e015bb5abdf25fc8e2aa63d895bae6bbec659e09f8313d2336fde947290a367559c4afef33d88\";\n\n\nfunction undefinedToNull(obj = {}) {\n    return Object.fromEntries(\n        Object.entries(obj).map(([k, v]) => [k, v === undefined ? null : v])\n    );\n}\n\n/**\n * 拡張SQLを実行して返す共通関数\n * - 返り値は「オブジェクト配列」か「生JSON文字列」かをコメントアウトで切替\n */\nasync function sqlTable(name, params = {}) {\n    const cleanParams = undefinedToNull(params);\n\n    const body = {\n        ApiVersion: API_VERSION,\n        Name: name,\n        ...(API_KEY ? { ApiKey: API_KEY } : {}),\n        ...(Object.keys(cleanParams).length ? { Params: cleanParams } : {}),\n    };\n\n    console.log(\"request body:\", body);\n\n    const res = await fetch(ENDPOINT, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        credentials: \"include\",\n        body: JSON.stringify(body),\n    });\n\n    if (!res.ok) {\n        const text = await res.text().catch(() => \"\");\n        throw new Error(`HTTP ${res.status} ${res.statusText}\\n${text}`);\n    }\n\n    // =============================\n    // 返り値の形式\n    // =============================\n\n    // ---- A) オブジェクト配列で返す（Response.Data.Table）----\n    const json = await res.json();\n    return json?.Response?.Data?.Table ?? [];\n\n    // ---- B) 生のJSON文字列で返す（そのままテキスト）----\n    // const text = await res.text();\n    // return text;\n}\n\n\nfunction sql(name, baseParams = {}) {\n    return async (params = {}) => {\n        // baseParams（既定） + params（上書き）を合体して送る\n        const merged = { ...baseParams, ...params };\n        return sqlTable(name, merged);\n    };\n}",
            "Id": 3
          },
          {
            "Title": "【テスト】拡張SQL呼び出し＋表作成",
            "Index": true,
            "Body": "(function ($) {\n  'use strict';\n\n  /*************************************************************************\n   * upcoming events — 初心者向けに丁寧にコメントした実装\n   *\n   * 全体の流れ（上位関数: upcomingEventsFormAction）\n   * 1) 入力（開始日・終了日）を取得\n   * 2) 取得した日付を alert で表示（今回の代替動作）\n   * 3) API の代わりにダミーデータを取得（fetchEventsDummy）\n   * 4) 各イベントの開催期間 (EventPeriod) を解析し、\n   *    期間内の日ごとに行を「穴埋め」する（expandEventsByPeriod）\n   * 5) 生成した行を HTML として描画する（renderEvents）\n   *\n   * 注意:\n   * - 外部公開は upcomingEventsFormAction のみ（onclick 用）\n   * - 他の関数は IIFE 内に閉じます（読みやすさ優先）\n   *************************************************************************/\n\n  /**\n   * getInputDates\n   * - 画面にある #fn-startDatet と #fn-endDate の input 要素から値を取得します。\n   * - 要素が無ければ空文字を返します（呼び出し側で扱いやすい形に統一するため）。\n   *\n   * 戻り値の構造:\n   *   { start: 'YYYY-MM-DD など', end: 'YYYY-MM-DD など' }\n   */\n  function getInputDates() {\n    // jQuery で要素を取得\n    var $start = $('#fn-startDate');\n    var $end = $('#fn-endDate');\n\n    // val() が undefined なら '' に統一して返す\n    return {\n      start: ($start.length ? String($start.val() || '') : ''),\n      end: ($end.length ? String($end.val() || '') : '')\n    };\n  }\n\n  /**\n   * showDatesAlert\n   * - 取得した日付を画面に alert で表示します（API 実行の代替挙動）。\n   * - ここはデバッグ／動作確認用なので、実運用では API 呼び出しに置き換えます。\n   */\n  function showDatesAlert(dates) {\n    // 短く見やすいメッセージで表示\n    alert('開始: ' + dates.start + '\\n終了: ' + dates.end);\n  }\n\n  /**\n   * fetchEventsDummy\n   * - 本来はサーバー API を叩いてイベントを取得する場所。\n   * - 今回はダミーの配列を返す（非同期のふりをするため Deferred を返す）。\n   *\n   * 引数:\n   *   dates - 将来 API に渡す可能性のある日付オブジェクト（今回は使わない）\n   *\n   * 戻り値:\n   *   jQuery Deferred.promise() を返す（resolve されると配列が返る）\n   */\n  async function fetchEventsDummy(dates) {\n\n    // パラメーターなし\n    const getEventScheduleList = sql(\n        \"getEventScheduleList\",\n        { DateFrom: dates.start, DateTo: dates.end }\n    );\n\n    const rows = await getEventScheduleList({});\n\n    console.log(\"rows length:\", rows.length);\n    console.table(rows[0]);\n    return rows;\n  }\n\n  /******************************************************************\n   * ここから「期間展開（穴埋め）」に関する補助関数群（初心者向けに丁寧に）\n   ******************************************************************/\n\n  /**\n   * parsePeriod\n   * - EventPeriod の文字列（例: \"2026/03/01 - 2026/03/03\"）から\n   *   開始日と終了日を Date オブジェクトにして返す関数\n   *\n   * - サポートする形式: yyyy/mm/dd または yyyy-mm-dd が本文中に 1 個以上あるもの\n   * - 解析に失敗したら null を返す（呼び出し側でフォールバック処理を行う）\n   *\n   * 戻り値の例:\n   *   { start: DateObject, end: DateObject } または null\n   */\n  function parsePeriod(periodStr) {\n    if (!periodStr || typeof periodStr !== 'string') return null;\n\n    // 正規表現で yyyy/mm/dd または yyyy-mm-dd をすべて探す\n    var re = /(\\d{4})[\\/\\-](\\d{1,2})[\\/\\-](\\d{1,2})/g;\n    var matches = [];\n    var m;\n    while ((m = re.exec(periodStr)) !== null) {\n      matches.push({ y: parseInt(m[1], 10), mo: parseInt(m[2], 10), d: parseInt(m[3], 10) });\n    }\n\n    // 日付が見つからなければ null\n    if (matches.length === 0) return null;\n\n    // 見つかった最初の 1 個を開始日、2 個目を終了日（2 個無ければ開始と同じ日を終了とする）\n    var s = matches[0];\n    var e = matches.length > 1 ? matches[1] : matches[0];\n\n    // Date コンストラクタに渡す（注意: 月は 0 起点なので -1 する）\n    var startDate = new Date(s.y, s.mo - 1, s.d);\n    var endDate = new Date(e.y, e.mo - 1, e.d);\n\n    // 日付の妥当性チェック\n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return null;\n\n    // start が end より後なら入れ替える（安全措置）\n    if (startDate.getTime() > endDate.getTime()) {\n      var tmp = startDate;\n      startDate = endDate;\n      endDate = tmp;\n    }\n\n    return { start: startDate, end: endDate };\n  }\n\n  /**\n   * getDatesInRange\n   * - 開始日から終了日まで（両端 inclusive）の Date オブジェクト配列を返す。\n   * - 例: start=2026-03-01, end=2026-03-03 => [2026-03-01, 2026-03-02, 2026-03-03]\n   *\n   * ※ Date はコピーして返します（元の Date を壊さないように）\n   */\n    function getDatesInRange(start, end, dates) {\n\n        // JSTチェック用（\"YYYY-MM-DD\"）\n        var checkStart = toCheckJSTDate(start);\n        var checkEnd   = toCheckJSTDate(end);\n\n        if (!dates || !dates.start || !dates.end) return [];\n\n        // 文字列 → Date\n        var rangeStart = new Date(dates.start);\n        var rangeEnd   = new Date(dates.end);\n\n        var periodStart = new Date(checkStart);\n        var periodEnd   = new Date(checkEnd);\n\n        if (\n            isNaN(rangeStart) || isNaN(rangeEnd) ||\n            isNaN(periodStart) || isNaN(periodEnd)\n        ) return [];\n\n        // ★ 重なっている開始日・終了日を求める\n        var actualStart = periodStart > rangeStart ? periodStart : rangeStart;\n        var actualEnd   = periodEnd   < rangeEnd   ? periodEnd   : rangeEnd;\n\n        // 重なりがなければ空\n        if (actualStart > actualEnd) return [];\n\n        var newDates = [];\n\n        // 年月日のみで回す\n        var cur = new Date(\n            actualStart.getFullYear(),\n            actualStart.getMonth(),\n            actualStart.getDate()\n        );\n        var last = new Date(\n            actualEnd.getFullYear(),\n            actualEnd.getMonth(),\n            actualEnd.getDate()\n        );\n\n        while (cur.getTime() <= last.getTime()) {\n            newDates.push(new Date(cur.getFullYear(), cur.getMonth(), cur.getDate()));\n            cur.setDate(cur.getDate() + 1);\n        }\n\n        return newDates;\n    }\n\n\n  /**\n   * formatToDisplayDate\n   * - Date オブジェクトを「3月1日」のような表示用文字列に変換する小さなユーティリティ\n   * - 表示を見やすくするために使います\n   */\n  function formatToDisplayDate(dateObj) {\n    if (!(dateObj instanceof Date) || isNaN(dateObj.getTime())) return '';\n    var month = dateObj.getMonth() + 1; // 月は 0 起点なので +1\n    var day = dateObj.getDate();\n    return month + '月' + day + '日';\n  }\n\n  /**\n   * expandEventsByPeriod\n   * - 元の eventsArray（各要素がイベントオブジェクト）を受け取り、\n   *   EventPeriod を解析して期間分（1日ごと）に複製・展開した新しい配列を返す関数\n   *\n   * - 例:\n   *   元: [{ EventPeriod: \"2026/03/01 - 2026/03/03\", ... }]\n   *   結果: [{ Date: \"3月1日\", ... }, { Date: \"3月2日\", ... }, { Date: \"3月3日\", ... }]\n   *\n   * - 解析に失敗した要素は「元の要素を1行分だけ使う」ようにしています（最小限のフォールバック）\n   */\n    function expandEventsByPeriod(eventsArray,dates) {\n    if (!Array.isArray(eventsArray)) return [];\n    var out = [];\n\n    const eventDaySiteId = \"253140\";\n    const periodSiteId = \"253154\";\n\n    eventsArray.forEach(function (item) {\n        if (item[\"開始日\"] && item[\"終了日\"]) {\n\n            // 期間（JST）\n            var start = toJSTDate(item[\"開始日\"]);\n            var end   = toJSTDate(item[\"終了日\"]);\n            let test = toJSTDate(item[\"勤務日\"])\n            if (!start || !end) return;\n\n            var days = getDatesInRange(start, end, dates);\n\n            days.forEach(function (d) {\n                var copy = Object.assign({}, item);\n\n                copy.Date = formatToDisplayDate(d);\n\n                // ★ copy に入れる（item は触らない）\n                copy[\"開催期間\"] =\n                    toJSTDateOnlyString(item[\"開始日\"]) + \"～\" +\n                    toJSTDateOnlyString(item[\"終了日\"]);\n\n                copy[\"イベントURL\"] =\n                    `http://192.168.10.67/items/${item[\"イベント番号\"]}`;\n\n                \n                var workDayKey = dateKeyFromJSTDate(test);\n\n                if (copy.Date === workDayKey && copy[\"ID\"]) {\n                    copy[\"勤務日\"] = toJSTDisplayString(item[\"勤務日\"]);\n                    copy[\"勤務開始時間\"] = toJSTDisplayString(item[\"勤務開始時間\"]);\n                    copy[\"勤務終了時間\"] = toJSTDisplayString(item[\"勤務終了時間\"]);\n                    copy[\"担当者\"] = item[\"担当者\"];\n                    copy[\"ID\"] = item[\"ID\"];\n\n                    // ★ ここは copy[\"ID\"] を使う\n                    copy[\"イベント当日URL\"] =\n                    `http://192.168.10.67/items/${copy[\"ID\"]}`;\n\n                } else {\n                    copy[\"勤務日\"] = null;\n                    copy[\"勤務開始時間\"] = null;\n                    copy[\"勤務終了時間\"] = null;\n                    copy[\"担当者\"] = null;\n                    copy[\"ID\"] = null;\n                    // copy[\"新規イベント当日\"] =`http://192.168.10.67/items/${eventDaySiteId}/new?FromSiteId=${periodSiteId}&LinkId=${item[\"イベント店舗ID\"]}&FromTabIndex=0`;\n                    copy[\"イベント当日URL\"] =`http://192.168.10.67/items/${eventDaySiteId}/new?FromSiteId=${periodSiteId}&LinkId=254586&FromTabIndex=0`;\n                }\n\n                out.push(copy);\n            });\n\n\n        } else {\n        out.push(Object.assign({}, item));\n        }\n    });\n    \n\n    return out;\n    }\n\n    function toCheckJSTDate(dateLike) {\n        var d = new Date(dateLike);\n        if (isNaN(d)) return null;\n\n        // JST (+9h)\n        d.setHours(d.getHours() + 9);\n\n        // YYYY-MM-DD 形式で返す\n        return (\n            d.getFullYear() + '-' +\n            String(d.getMonth() + 1).padStart(2, '0') + '-' +\n            String(d.getDate()).padStart(2, '0')\n        );\n    }\n\n\n    //9時間プラス\n    function toJSTDate(dateLike) {\n        var d = new Date(dateLike);\n        if (isNaN(d)) return null;\n        d.setHours(d.getHours() + 9);\n        return d;\n    }\n\n\n    //表示用に変換\n    function toJSTDisplayString(dateLike) {\n        var d = toJSTDate(dateLike);\n        if (!d) return null;\n\n        var y = d.getFullYear();\n        var m = String(d.getMonth() + 1).padStart(2, '0');\n        var day = String(d.getDate()).padStart(2, '0');\n        var h = String(d.getHours()).padStart(2, '0');\n        var min = String(d.getMinutes()).padStart(2, '0');\n\n        // ★ 時刻を持っているか判定\n        var hasTime = d.getHours() !== 0 || d.getMinutes() !== 0 || d.getSeconds() !== 0;\n\n        if (hasTime) {\n            // 勤務開始時間・勤務終了時間 用\n            return `${y}/${m}/${day} ${h}:${min}`;\n        } else {\n            // 日付のみ 用\n            return `${y}年${m}月${day}日`;\n        }\n    }\n\n    //開催期間表示用\n    function toJSTDateOnlyString(dateLike) {\n        var d = toJSTDate(dateLike);\n        if (!d) return null;\n\n        return (\n            d.getFullYear() + '年' +\n            String(d.getMonth() + 1).padStart(2, '0') + '月' +\n            String(d.getDate()).padStart(2, '0') + '日'\n        );\n        }\n\n        function dateKeyFromJSTDate(d) {\n        if (!(d instanceof Date) || isNaN(d.getTime())) return '';\n        return (d.getMonth() + 1) + '月' + d.getDate() + '日';\n    }\n\n\n  /******************************************************************\n   * HTML 作成（各セル／各列を作る関数群）\n   * - buildCellElement: 1 セル（ヘッダ + 本文）を作る\n   * - buildColumnElement: 1 レコード（複数セル）を作る\n   *\n   * これらは DOM を直接作る補助で、読みやすさを優先して分割しています。\n   ******************************************************************/\n\n  /**\n   * buildCellElement\n   * - data-style 属性、ヘッダ表示テキスト、本文を受け取りセルの DOM を返す\n   * - bodyContent が文字列ならテキストとして追加、jQuery 要素ならそのまま追加\n   */\n  function buildCellElement(dataStyle, headText, bodyContent) {\n    // 親のセル要素 <div class=\"sdt-table-variable-cell\" data-style=\"...\">\n    var $cell = $('<div>').addClass('sdt-table-variable-cell').attr('data-style', dataStyle);\n\n    // ヘッダ部\n    var $head = $('<div>').addClass('sdt-table-variable-cell-head');\n    $head.append($('<p>').addClass('sdt-table-variable-cell-head__text').text(headText));\n    $cell.append($head);\n\n    // 本文部\n    var $body = $('<div>').addClass('sdt-table-variable-cell-body');\n    var $bodyTextWrap = $('<p>').addClass('sdt-table-variable-cell-body__text');\n\n    if (bodyContent && bodyContent instanceof jQuery) {\n      // もしリンクなど jQuery 要素が渡されたらそれをそのまま入れる\n      $bodyTextWrap.append(bodyContent);\n    } else {\n      // 文字列ならエスケープ（text() を使うことで HTML 挿入を防ぐ）\n      $bodyTextWrap.text(String(bodyContent || ''));\n    }\n\n    $body.append($bodyTextWrap);\n    $cell.append($body);\n\n    return $cell;\n  }\n\n  /**\n   * buildColumnElement\n   * - 1 レコード（イベント）から「column」DOM を作ります。\n   * - buildCellElement を使ってセルを順に追加するだけなので読みやすく少ない処理量にしています。\n   *\n   * 入力 item の主な期待プロパティ:\n   *   Date, Category, Area, EventName, EventUrl, BusinessStore, EventPeriod, StartTime, EndTime, PersonCharge\n   */\n  function buildColumnElement(item) {\n\n    var $col = $('<div>').addClass('sdt-table-variable-column');\n\n    // 日付セル\n    $col.append(buildCellElement('Date', '日付', item.Date || ''));\n\n    // カテゴリ\n    $col.append(buildCellElement('Category', 'カテゴリー', item[\"カテゴリ\"] || ''));\n\n    // エリア\n    $col.append(buildCellElement('Area', '開催エリア', item[\"開催エリア\"]  || ''));\n\n    // エリア詳細\n    $col.append(buildCellElement('AreaDetail', '開催エリア詳細', item[\"開催エリア詳細\"]  || ''));\n\n    // イベント名（リンク）\n    var $link = $('<a>').addClass('sdt-link').attr('href', item[\"イベントURL\"] || '#').text(item[\"イベント名称・出店先\"] || 'イベント名称未設定');\n    $col.append(buildCellElement('EventName', 'イベント名称・出店先', $link));\n\n    // 事業名・店舗名\n    $col.append(buildCellElement('BusinessStore', '事業名・店舗名', item[\"店舗名\"] || ''));\n\n    // 開催期間（元の文字列を表示）\n    $col.append(buildCellElement('EventPeriod', '開催期間', item[\"開催期間\"] || ''));\n\n    // 勤務開始時間 / 勤務終了時間\n    $col.append(buildCellElement('StartTime', '勤務開始時間', item[\"勤務開始時間\"] || ''));\n    $col.append(buildCellElement('EndTime', '勤務終了時間', item[\"勤務終了時間\"] || ''));\n\n    // 担当者\n    $col.append(buildCellElement('PersonCharge', '担当者', item[\"担当者\"] || ''));\n\n    // 入力ボタン（リンク） - ページ遷移させたくないので preventDefault している\n    var $inputA = $('<a>')\n      .addClass('sdt-inputButton')\n      .attr('href', item[\"イベント当日URL\"] )\n      .text('入力')\n      .on('click', function (e) {\n        // e.preventDefault();\n        // ここで必要なら別の処理（モーダル表示等）を呼び出す\n      });\n\n    $col.append(buildCellElement('Button', '入力ボタン', $inputA));\n\n    return $col;\n  }\n\n  /******************************************************************\n   * 描画処理\n   * - renderEvents: 生成した配列を #sdt-upcomingEvents-table の中に挿入する\n   ******************************************************************/\n\n  /**\n   * renderEvents\n   * - eventsArray が配列かをチェックし、挿入先要素がある場合は中身をクリアして\n   *   配列の順番どおりに column 要素を追加します。\n   *\n   * 挿入先セレクタ:\n   *   #sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap\n   */\n  function renderEvents(eventsArray) {\n  if (!Array.isArray(eventsArray)) return;\n\n  var $wrap = $('#sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap');\n  if ($wrap.length === 0) return;\n\n  var sorted = eventsArray.slice().sort(function (a, b) {\n\n    function toComparableDate(item) {\n      if (!item.Date) return null;\n\n      // 「1月12日」形式\n      var m = item.Date.match(/(\\d+)月(\\d+)日/);\n      if (!m) return null;\n\n      var month = Number(m[1]);\n      var day   = Number(m[2]);\n\n      // 開始日の年・月\n      if (!item[\"開始日\"]) return null;\n      var start = new Date(item[\"開始日\"]);\n      var year = start.getFullYear();\n      var startMonth = start.getMonth() + 1;\n\n      // ★ 年またぎ補正（開始日が12月 & 表示月が1月）\n      if (startMonth === 12 && month === 1) {\n        year += 1;\n      }\n\n      return new Date(year, month - 1, day);\n    }\n\n    var da = toComparableDate(a);\n    var db = toComparableDate(b);\n\n    if (!da && !db) return 0;\n    if (!da) return 1;\n    if (!db) return -1;\n\n    return da.getTime() - db.getTime();\n  });\n\n  // 描画\n  $wrap.empty();\n\n  sorted.forEach(function (item) {\n    if (item[\"開始日\"] && item[\"終了日\"]) {\n      $wrap.append(buildColumnElement(item));\n    }\n  });\n}\n\n\n\n\n\n  /******************************************************************\n   * オーケストレーション関数（ボタン onclick で呼ばれる）\n   *\n   * - 入力取得 → alert 表示 → ダミーデータ取得 → 期間展開 → 描画\n   * - シンプルで追いやすい順序にしています（初心者でもたどりやすい）\n   ******************************************************************/\n    //画面表示時デフォルト値表示\n    $(function () {\n\n        // 今日\n        var today = new Date();\n\n        // 6日後\n        var end = new Date();\n        end.setDate(today.getDate() + 6);\n\n        // YYYY-MM-DD に整形\n        function toYMD(d) {\n            return (\n            d.getFullYear() + '-' +\n            String(d.getMonth() + 1).padStart(2, '0') + '-' +\n            String(d.getDate()).padStart(2, '0')\n            );\n        }\n\n        // 入力欄にセット\n        $('#fn-startDate').val(toYMD(today));\n        $('#fn-endDate').val(toYMD(end));\n\n        // 初期表示用 dates\n        var dates = {\n            start: toYMD(today),\n            end: toYMD(end)\n        };\n\n        // ★ 画面表示直後に実行\n        loadEventsByDates(dates);\n    });\n\n    //検索クリック時\n    async function upcomingEventsFormAction(evt) {\n        if (evt && typeof evt.preventDefault === 'function') {\n            evt.preventDefault();\n        }\n\n        // 入力値を取得\n        var dates = getInputDates();\n\n        // 確認用（必要なら）\n        showDatesAlert(dates);\n\n        // 共通処理を呼ぶ\n        await loadEventsByDates(dates);\n    }\n\n\n    async function loadEventsByDates(dates) {\n        try {\n            const eventsArray = await fetchEventsDummy(dates);\n            const expanded = expandEventsByPeriod(eventsArray, dates);\n\n            console.log(\"expanded\");\n            console.log(expanded);\n\n            renderEvents(expanded);\n        } catch (err) {\n            console.error('fetchEventsDummy failed', err);\n        }\n    }\n\n\n  // グローバルに公開（onclick 属性で呼び出せるように）\n  window.upcomingEventsFormAction = upcomingEventsFormAction;\n\n  /*************************************************************************\n   * 補足（使用方法）\n   * - ボタンに: <button onclick=\"upcomingEventsFormAction(event)\">実行</button>\n   * - フォームに: <input id=\"fn-startDatet\"> と <input id=\"fn-endDate\"> を用意\n   * - 描画先は: #sdt-upcomingEvents-table .sdt-table-variable .sdt-table-variable-wrap\n   *\n   * 変更・拡張ポイント（将来の実装メモ）\n   * - fetchEventsDummy を $.ajax に差し替えて実データを取得する\n   * - 日付形式のバリエーションが増えたら parsePeriod を拡張する\n   *************************************************************************/\n\n})(jQuery);\n",
            "Id": 4
          },
          {
            "Title": "【テスト】拡張SQL呼び出しのみ",
            "Index": true,
            "Disabled": true,
            "Body": "async function testGetEventScheduleList() {\n\n  // パラメーターなし\n  const getEventScheduleList = sql(\n    \"getEventScheduleList\",\n    { DateFrom: null, DateTo: null }\n  );\n\n  const rows = await getEventScheduleList({});\n\n  console.log(\"rows length:\", rows.length);\n  console.table(rows[1][\"イベント番号\"]);\n}\n\n// 実行\ntestGetEventScheduleList();",
            "Id": 5
          }
        ],
        "Htmls": [
          {
            "Title": "【表示制御】開催イベント一覧HTML",
            "PositionType": 1010,
            "Index": true,
            "Body": "        <div id=\"fn-upcomingEvents\" class=\"sdt-upcomingEvents\">\n            <!-- 開催イベント一覧全体ラップ -->\n            <div class=\"sdt-upcomingEvents-wrap\">\n\n\n                <!-- 画面タイトル -->\n                <h2 class=\"sdt-upcomingEvents-title\">\n                    <span class=\"sdt-upcomingEvents-title__text\">開催イベント一覧</span>\n                </h2>\n\n                <!-- 検索フォーム -->\n                <div class=\"sdt-upcomingEvents-form\">\n                    <form id=\"fn-upcomingEvents-form\" class=\"sdt-upcomingEvents-form__area\">\n                        <p class=\"sdt-form-title\">日付</p>\n                        <div class=\"sdt-form-data\">\n                            <label class=\"sdt-form-label\">\n                                <input id=\"fn-startDate\" class=\"sdt-input\" type=\"date\">\n                            </label>\n                        </div>\n                        <span class=\"sdt-form-data__tilde\">~</span>\n                        <div class=\"sdt-form-data\">\n                            <label class=\"sdt-form-label\">\n                                <input id=\"fn-endDate\" class=\"sdt-input\" type=\"date\">\n                            </label>\n                        </div>\n                        <button class=\"sdt-button\" type=\"search\" onclick=\"upcomingEventsFormAction()\">\n                            <span class=\"sdt-button__text\">検索</span>\n                        </button>\n                    </form>\n                </div>\n\n\n                <!-- 一覧テーブル -->\n                <div id=\"sdt-upcomingEvents-table\" class=\"sdt-upcomingEvents-table\">\n\n                    <div class=\"sdt-table-variable\">\n                        <div class=\"sdt-table-variable-wrap\">\n\n                            <!-- ここにカラムを挿入 -->\n\n\n                        </div>\n                    </div>\n\n\n\n                </div>\n            </div>\n        </div>",
            "Id": 1
          }
        ],
        "NoDisplayIfReadOnly": false
      },
      "Publish": false,
      "DisableCrossSearch": false,
      "Comments": []
    }
  ],
  "Data": [],
  "Permissions": [
    {
      "SiteId": 253771,
      "Permissions": []
    }
  ],
  "PermissionIdList": {
    "DeptIdList": [],
    "GroupIdList": [],
    "UserIdList": []
  }
}